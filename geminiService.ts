import { GoogleGenAI, Type } from "@google/genai";

const API_KEY = process.env.API_KEY;

if (!API_KEY) {
  throw new Error("API_KEY environment variable is not set.");
}

const ai = new GoogleGenAI({ apiKey: API_KEY });

export async function planImageGeneration(userPrompt: string): Promise<{ imagePrompt: string; hindiText: string; theme: string }> {
  try {
    const systemInstruction = `You are a spiritual and mythological art director. Your task is to interpret the user's devotional or poetic prompt and create a generation plan.
1.  Extract the exact 'hindiText' the user wants on the image, including all emojis and decorative punctuation like '!!'.
2.  Analyze the deep, spiritual 'theme' (e.g., "divine guidance of Krishna", "solitude of a warrior", "cosmic energy of Shiva", "peace in devotion").
3.  Create a highly detailed, artistic, and painterly 'imagePrompt' in English. This prompt must describe a divine, ethereal, and emotional scene. **Crucially, the composition must be deliberately designed to feature text as a focal point.** Describe a beautiful, natural area for text (e.g., a misty sky, a glowing part of the background, a calm water surface). The scene should feel like a master painter composed it specifically for the words to be placed there. Focus on silhouettes, divine light sources, rich color palettes, and a sense of mystique. **The generated image must be purely visual and contain absolutely NO text, letters, or watermarks.**

Your output must be a valid JSON object with 'imagePrompt', 'hindiText', and 'theme'.`;

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: `User request: "${userPrompt}"`,
      config: {
        systemInstruction,
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            imagePrompt: { 
              type: Type.STRING, 
              description: "A detailed, painterly English prompt for an image generation model, focused on a divine, ethereal style with space for text." 
            },
            hindiText: { 
              type: Type.STRING, 
              description: "The exact Hindi text to be overlaid on the image, including any emojis and punctuation." 
            },
            theme: {
              type: Type.STRING,
              description: "The deep spiritual or emotional theme of the prompt."
            }
          },
          required: ['imagePrompt', 'hindiText', 'theme'],
        }
      },
    });

    const jsonString = response.text;
    const result = JSON.parse(jsonString);
    
    if (typeof result.imagePrompt !== 'string' || typeof result.hindiText !== 'string' || typeof result.theme !== 'string' || result.imagePrompt.trim() === '' || result.hindiText.trim() === '') {
        throw new Error('Could not extract a valid plan from the request.');
    }

    return result;

  } catch (error) {
    console.error('Error in planning phase:', error);
    throw new Error(`Failed to understand the prompt: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

export async function generateBackgroundImage(prompt: string, aspectRatio: '1:1' | '9:16' | '16:9' | '3:4'): Promise<string> {
  try {
    const response = await ai.models.generateImages({
      model: 'imagen-4.0-generate-001',
      prompt: `digital painting, ethereal, divine, cinematic lighting, ${prompt}, NO text, no writing, no letters, watermark-free`,
      config: {
        numberOfImages: 1,
        outputMimeType: 'image/jpeg',
        aspectRatio: aspectRatio,
      },
    });

    const imageBytes = response.generatedImages?.[0]?.image?.imageBytes;
    if (imageBytes) {
      return imageBytes;
    }
    
    throw new Error('No image was generated by the API.');

  } catch (error) {
    console.error('Error generating image with Gemini:', error);
    throw new Error(`Gemini API Error: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

interface TextPlacementAnalysis {
  x: number;
  y: number;
  textColor: string;
  shadowColor: string;
  shadowBlur: number;
  hindiText: string;
  fontStyle: 'elegant-serif' | 'bold-sans-serif' | 'calligraphic';
  fontSize: number;
}

export async function analyzeImageForTextPlacement(base64Image: string, textToPlace: string, theme: string): Promise<TextPlacementAnalysis> {
  try {
    const prompt = `You are an experienced art director specializing in spiritual and poetic social media graphics.
Analyze the provided image and the Hindi text: '${textToPlace}'. The deep emotional theme is: '${theme}'.
Your goal is to create a design that is beautiful, harmonious, and highly readable. Your output must be a JSON object with a complete styling plan.

1.  **Coordinates**: Find the optimal (x, y) center coordinates (as percentages 0-100) within an area of low visual complexity (like a clear sky, misty background, etc.).
2.  **Font Style**: Based on the theme, suggest a 'fontStyle' to amplify the message's impact. Your options are: 'elegant-serif' (for wisdom, peace), 'bold-sans-serif' (for power, impact), or 'calligraphic' (for poetic feelings).
3.  **Font Size**: Suggest a large, impactful 'fontSize' as a percentage of the image's width (e.g., 6 for a large title, 4.5 for a longer quote). The text needs to be a primary feature, not an afterthought.
4.  **Elegant Color & Readability**:
    *   **'textColor'**: Choose a single, elegant, and highly readable hex color code. Prioritize clarity and artistic harmony. For dark, spiritual backgrounds, often a bright, divine color like white (#FFFFFF), light gold (#FFD700), or soft cream (#FFFDD0) works best.
    *   **'shadowColor' & 'shadowBlur'**: To make the text readable and give it a divine feel, suggest a 'shadowColor' that creates a **radiant yellow or golden glow** (e.g., #FFD700, #FBBF24). This lifts the text from the image. Suggest a 'shadowBlur' radius (e.g., 15, 25).
5.  **Composition**: Format the 'hindiText' with natural, poetic line breaks (using \\n). Ensure headers are given their own line. Do not alter words or emojis.`;

    const imagePart = {
      inlineData: {
        mimeType: 'image/jpeg',
        data: base64Image,
      },
    };

    const textPart = { text: prompt };

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: { parts: [imagePart, textPart] },
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            x: { type: Type.NUMBER, description: 'X coordinate percentage (0-100) for the center of the text.' },
            y: { type: Type.NUMBER, description: 'Y coordinate percentage (0-100) for the center of the text block.' },
            textColor: { 
                type: Type.STRING, 
                description: "A single hex color code for the text that is elegant and highly readable." 
            },
            shadowColor: { type: Type.STRING, description: "Subtle shadow color (hex code) for a radiant yellow or golden glow." },
            shadowBlur: { type: Type.NUMBER, description: "Generous blur radius for the shadow (e.g., 20)." },
            hindiText: {type: Type.STRING, description: "The original Hindi text formatted with '\\n' for optimal line breaks."},
            fontStyle: { type: Type.STRING, description: "The font style to use: 'elegant-serif', 'bold-sans-serif', or 'calligraphic'." },
            fontSize: { type: Type.NUMBER, description: "Optimal impactful font size as a percentage of the image width (e.g., 6)." },
          },
          required: ['x', 'y', 'textColor', 'shadowColor', 'shadowBlur', 'hindiText', 'fontStyle', 'fontSize'],
        }
      },
    });

    const jsonString = response.text;
    const result: TextPlacementAnalysis = JSON.parse(jsonString);

    if (typeof result.x !== 'number' || typeof result.y !== 'number' || typeof result.textColor !== 'string' || typeof result.shadowColor !== 'string' || typeof result.shadowBlur !== 'number' || typeof result.hindiText !== 'string' || typeof result.fontStyle !== 'string' || typeof result.fontSize !== 'number') {
        throw new Error('Invalid JSON structure from analysis API.');
    }
    
    result.x = Math.max(5, Math.min(95, result.x));
    result.y = Math.max(5, Math.min(95, result.y));
    result.shadowBlur = Math.max(0, result.shadowBlur);
    result.fontSize = Math.max(3, Math.min(20, result.fontSize)); // Increased min font size

    return result;

  } catch (error) {
    console.error('Error analyzing image with Gemini:', error);
    console.warn('Analysis failed, falling back to default placement.');
    return { 
        x: 50, 
        y: 50, 
        textColor: '#FFFFFF', 
        shadowColor: '#FFD700', 
        shadowBlur: 15,
        hindiText: textToPlace.replace(/!! /g, '!!\\n').replace(/\.\.!!/g, '..!!\\n'),
        fontStyle: 'bold-sans-serif',
        fontSize: 6, // Increased fallback font size
    };
  }
}
